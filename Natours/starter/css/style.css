/*
COLORS:

Light green: #7ed56f
Medium green: #55c57a
Dark green: #28b485

*/

/*
Todos los elementos HTML y los generados con pseudoclases deben tener este comportamiento
*/
*,
*::after,
*::before {
  margin: 0;
  padding: 0;
  box-sizing: inherit; /* Hereda el border-sizing de manera forzada */
}

/* Se asigna en html el font-size para poder utilizar rems en el resto de la app */
html {
  font-size: 62.5%;
  /*
  Se utiliza porcentajes para que calcule el tamaño de la fuente final segun el valor dado por el navegador. 
  Se utiliza 62.5% porque buscamos que si se usa el valor predeterminado, 16px, se asignen 10px 
  */
}

/* Siempre las fuentes van en el body, ya que estas se heredan por todas las etiquetas hijas */
body {
  font-family: "Lato", sans-serif;
  font-weight: 400;
  line-height: 1.7;
  color: #777;

  /* Esto ya no se hereda */
  padding: 30px;

  box-sizing: border-box; /* Especifica que los tamaños de bordes,margenes o paddings esten dentro del tamaño total del componente (componente de 100px con borde de 10px === caja de 90px + borde de 10px) */
}

.header {
  height: 95vh; /* vh es un porcentaje del tamaño que tenga la pantalla */
  background-image: linear-gradient(
      to right bottom,
      rgba(126, 213, 111, 0.8),
      rgba(39, 180, 133, 0.8)
    ),
    url("../img/hero.jpg");
  background-size: cover; /* sin importar el tamaño de la pantalla, siempre se intenta que la imagen se acomode a la misma */
  background-position: top; /* si la imagen se tiene que recortar, el "top" se mantiene fijo y corta por debajo */

  clip-path: polygon(
    0 0,
    100% 0,
    100% 75vh,
    0 100%
  ); /* espeficica que es lo que realmente se ve del componente marcando puntos cardinales, el orden de los puntos es en sentido horario siempre teniendo como referencia el primero de todos */

  position: relative; /* Con esto la clase "logo_box" tomara este elemento como referencia como punto de partida para calcular su posicion */
}

.logo_box {
  position: absolute;
  top: 4rem;
  left: 4rem;
}

.logo {
  height: 4rem;
}

/* todo lo que se encuentra dentro de esta clase es necesario para que un elemento este justo en el centro del elemento padre y asi se mantenga sin importar los cambios de tamaño de la pantalla */
.text_box {
  position: absolute;
  top: 40%; /* deberia ser 50 pero es 40 ya que la imagen de fondo esta recortada con "clip-path" */
  left: 50%;
  transform: translate(-50%, -50%);
  text-align: center;
}

.primary_heading {
  color: #fff;
  text-transform: uppercase;
  margin-bottom: 6rem;
}

.primary_heading_main {
  display: block;
  font-size: 6rem; /* tamaño de la fuente */
  font-weight: 400; /* ancho de la fuente */
  letter-spacing: 3rem; /* espacio en blanco entre letra y letra */

  animation-name: moveInLeft; /* Nombre de la animacion */
  animation-duration: 1s; /* Duracion de la animacion */
  animation-timing-function: ease-in; /* Funcion que modifica como utiliza el tiempo de la animacion  
  Mas info: https://developer.mozilla.org/en-US/docs/Web/CSS/animation-timing-function */

  /*
  animation-delay: 3s; Setea un tiempo de espera antes de realizar la animacion
  animation-iteration-count: 3; Cantidad de veces que se repetira la animacion
  */
}

.primary_heading_sub {
  display: block;
  font-size: 3rem;
  font-weight: 700;
  letter-spacing: 1.3rem;

  animation: moveInRight 1s ease-in; /* Forma abreviada de configurar una animacion. El orden de los parametro es: 
  name, duration, timing-function, delay, iteration-count, direction, fill-mode */
}

/*
 Los keyframes son usados para crear animaciones totalmente personalzadas, se puede interactuar con cada momento de la animacion utilizando %.
 Se recomienda solo modificar 2 propiedades de los elementos la opacidad y el transform ya que es para lo que estan preparados los navegadores  
 */
@keyframes moveInLeft {
  0% {
    opacity: 0;
    transform: translateX(-10rem);
  }

  80% {
    transform: translateX(1rem);
  }

  100% {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes moveInRight {
  0% {
    opacity: 0;
    transform: translateX(10rem);
  }

  80% {
    transform: translateX(-1rem);
  }

  100% {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes moveInBottom {
  0% {
    opacity: 0;
    transform: translateY(3rem);
  }

  100% {
    opacity: 1;
    transform: translateX(0);
  }
}

/*
 :link y :visited son pseudo-clases que se ejecutan bajo cierta condicion, en este caso :link es cuando una etiqueta a nunca fue visitada y
 :visited es cuando una etiqueta a fue vsitada y se vuelve a ver
 */
.btn:link,
.btn:visited {
  text-decoration: none;
  text-transform: uppercase;
  font-size: 1.6rem;
  padding: 1.5rem 4rem;
  border-radius: 10rem;
  display: inline-block;
  transition: all 0.2s; /* Es la 2da forma de crear animaciones. En este caso primero definimos que propiedad queremos animar y luego el tiempo que dura */
  position: relative; /* Necesario para que su hijo virtual se posicione detras de el correctamente */
}

/* pseudo-clase que se activa cuando el mouse esta sobre el elemento */
.btn:hover {
  transform: translateY(
    -0.3rem
  ); /* Esto junto con el transition movera hacia arriba el boton de manera suave */
  box-shadow: 0 2rem 1.5rem rgba(0, 0, 0, 0.2); /* Mismo caso que arriba, genera una sombra de manera suave teniendo en cuenta el transition */
}

/* pseudo-clase que se activa cuando se clickea el elemento */
.btn:active {
  transform: translateY(-0.1rem);
  box-shadow: 0 1rem 1.5rem rgba(0, 0, 0, 0.2);
}

.btn_white {
  background-color: #fff;
  color: #777;
}

/*
 Crea un elemento virtual justo despues del elemento que tiene la clase asociada. 
 Este elemento virtual se comporta como un hijo del elemento con la clase 
*/
.btn::after {
  content: ""; /* Es obligatorio para que el elemento se vea. El contenido puede ser "", pero la propiedad debe declararse */
  display: inline-block; /* Igual que arriba */
  width: 100%;
  height: 100%;
  border-radius: 10rem;

  /* Posicionamiento detras del padre */
  position: absolute;
  top: 0;
  left: 0;
  z-index: -1;

  /* Animacion */
  transition: all 0.4s;
}

.btn_white::after {
  background-color: #fff;
}

/* Aplicar propiedades en el elemento virtual cuando se posiciona el mouse sobre el */
.btn:hover::after {
  transform: scaleX(1.4) scaleY(1.6); /* Escala el elemento. Si el escalado es el mismo en ambas direcciones se puede usar scale() */
  opacity: 0;
}

.btn_animated {
  animation: moveInBottom 0.5s ease-out 0.75s;
  animation-fill-mode: backwards; /* Hace que las propiedades que se encuentran en el 0% de la animacion se seteen en el elemento antes de comenzar la animacion */
}
